*WHEN?*

### 一些代码的坏味道

**Duplicated Code （重复代码）**

1. 相同的代码: 提取出来
2. 相似的代码: 分离相似和差异部分，提取出相似部分
3. 不同的算法，同样的工作：用最清晰的那个算法代替其他所有

**Long Method （过长函数）**

1. 短小的函数更长寿，顺便给短函数取个好名字，好让它一目了然。
2. 积极得分解函数。当你觉得需要注释的时候，你应该把需要说明的东西写进一个独立函数中，并以其用途（!而非实现手法）命名。
3. 检索函数中的注释处，流程控制处，这些往往是十分需要分解的地方。

**Large Class （过大的类）**

*PS: 类在我的日常语言里面用得比较少，所以我换个思路*

1. 一个模块内包含的方法和引用的依赖过多的时候，适当得分解成多个模块。
2. 内部消化掉模块中的重复代码，将“五个百行函数”整理成五个“十行函数”和十个提炼出来的“双行函数”。
3. 先确定消费者需要的接口，从这个角度出发或许能够帮助你看清如何分解这个模块。
4. 如果是一些GUI类，你可能需要在多处时候重复的数据，你使用*观察者模式*, *P/S模式*等可以把这些数据独立出来供视图消费。

**Long Parameter List（过长参数列）**

Personal Point: 现代编程语言，基本上至少都具备闭包或面向对象的能力，不容易出现过长参数列这种情况。除非你发现了你的参数经常变动(这大概就是设计上有误)，除此之外基本上不需要担心什么。

**Divergent Change（发散式变化）**

> 我们**希望**软件能够更容易被修改——毕竟软件再怎么说本来就该是**软**的。一旦修改，我们希望能够跳到系统的某一点，只在该出做修改，如果做不到这一点，你就能嗅出两种刺鼻味道中的一中了。

*发散式修改*: 如果一个类中的不同部分，会因为不同方向的修改产生调整，那么就应该试图运用*Extract Class(149)*去把不同部分的内容分离出来，尽量一个类只针对某一个外界变化。

**Shotgun Surgery（霰弹式修改）**

这个情况类似前者，但恰恰相反。 如果每遇到外界变化，所需要修改的代码遍布各处；这样的话不但很难找到它们，还很容易忘记某个重要的改动。

这时，应该将这些需要修改的方法和字段放入同一个类中。如果眼下没有适合存放的类，那就创造一个。TODO: What is *Inline Class* ?

此状况和前者的原则是一样的：使“外界变化”与“需要修改的类”趋于一一对应。

**Feature Envy（依赖情结）**

>  对象技术的全部要点在于：这是一种“将数据和对数据的操作行为包装在一起”的技术。因此，自然而然会有一种经典气味：函数对某个类的兴趣高过对自己所处类的兴趣。

1. 在扩展类的时候及时得进行调整，如果发现了有某些函数更依赖于其他类的数据，那就把他移动过去。
2. 在更复杂的情况下，可以借助一些设计模式去弥补语言上的不足，如：GoF的Strategy和Visitor, KentBeck的Self Delegation。
3. 根本原则：把需要变化的数据和行为绑定在一起，如果有例外，我们就搬移那些行为，保持变化只在一地发生。

**Data Clumps（数据泥团）**

1. 数据项经常会因为内在联系成群结队得待在一起，这时候就应该把这部分数据提取出一个新类，并着手于寻找Feature Envy, 重新梳理程序结构。
2. 一个好的评判方法：删掉众多数据的一项。这么做，其他数据有没有因而失去意义？

**Primitive Obsession（基本类型偏执）**

1. 用小对象代替基本类型，如Range, Phone, ZIP, Money等
2. 用小对象代替Array，字段集合，参数列(Introduce Parameter Object?)等

**Switch Statements**（switch 惊悚现身）

用多态代替Switch, 除非是单一函数中稍微用一下switch做流程控制，否则不建议使用Switch。

**Switch Statements**（平行继承体系）

意义不明，貌似说有两个继承体系十分相似的类，就把它们修修改改合成一个吧。

**Lazy class**（冗赘类）

你所创建的内容都是需要成本去理解的，如果是无用的内容就让他庄严赴义吧。

**Speculative Generality**（夸夸其谈的未来性）

1. 如果这个抽象类没啥用，就Inline掉吧
2. 如果函数参数为用上，就删掉吧
3. 如果函数名有多余的抽象味道，就应该重命名它，让他更具备现实味道一点。

如果函数和类唯一哥用户是测试用例，那么就是这个味道了。

**Temporary Field （令人迷惑的暂时字段）**

...

暂时对嗅出味道已经没什么实感了，先往下看实际操作方法再回头查阅。



*PreRefactory*

> 如果你想进行重构，首要前提就是拥有一个可靠的（自动化）测试环境。

这部分确实没有什么可以说的，Java 的测试环境我暂时用不到。Elixir 这边自带的 ExUnit 基本满足了需求，Node.js 大概会用一下 jest 或 ava.js。总而言之这个东西我认为是利用搜索引擎就可以满足的，就不列举了。



*Refactory*

这部分确实是太琐碎了，基本上是类似于词典的形式，具体的建议看原文吧。