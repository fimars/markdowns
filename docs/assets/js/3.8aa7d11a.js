(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{28:function(e,n,t){"use strict";t.r(n);var o=t(1),r=t(32),a=t.n(r),s=t(33),c=t.n(s),i=function(){return o.createElement("div",{className:"markdown-body section",dangerouslySetInnerHTML:{__html:'<h2 id="bash-guide-notes-📒">Bash Guide Notes 📒</h2>\n<blockquote>\n<p>Bash Guide: <a href="http://guide.bash.academy/expansions/">http://guide.bash.academy/expansions/</a></p>\n<p> The Chapter: Variables and Expansions</p>\n</blockquote>\n<p>今天也有在看Parcel和Parcel的代码，因为自己的项目用到了这个新的Bundler库，看到一个很有意思的<a href="https://github.com/parcel-bundler/parcel/issues/110#issuecomment-350259878">issue</a>。里面这个shell蛮有意思的。</p>\n<h3 id="路径扩展-pathname-expansion">路径扩展 (Pathname Expansion)</h3>\n<p>看个例子:</p>\n<pre><code class="language-bash">$ cd ~/Downloads\n$ rm -v *\nremoved &#39;05 *****.ogg&#39;\nremoved &#39;07 *****.ogg&#39;\n$ls\n$</code></pre>\n<p><code>rm -v</code> 后面的<code>*</code>会匹配到<code>Downloads</code>下所有的文件，这套在bash上使用的扩展匹配符号被叫做<code>Glob</code>，下面这个表格来自<a href="http://guide.bash.academy/expansions/?=Pathname_Expansion#p1.1.0_4">原文</a>。</p>\n<table>\n<thead>\n<tr>\n<th>Glob</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>*</code></td>\n<td>匹配N个字符，N包括0</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>匹配0 ~ 1个字符</td>\n</tr>\n<tr>\n<td><code>[characters]</code></td>\n<td>匹配一个字符，范围来自<code>[...]</code>中的内容，类似正则表达式的<code>[]</code></td>\n</tr>\n<tr>\n<td><code>[:classname:]</code></td>\n<td>类似上一个命令. 支持一系列模式，包括: <em>alnum</em>, <em>alpha</em>, <em>ascii</em>, <em>blank</em>, <em>cntrl</em>, <em>digit</em>, <em>graph</em>, <em>lower</em>, <em>print</em>, <em>punct</em>, <em>space</em>, <em>upper</em>, <em>word</em>, <em>xdigit</em></td>\n</tr>\n</tbody></table>\n<p>可以指令开启更多的glob匹配，具体就不列举了，大概是正则表达式常用的符号<a href="http://guide.bash.academy/expansions/?=Pathname_Expansion#p1.1.0_9">原文</a>。</p>\n<pre><code class="language-bash">$ shopt -s extglob</code></pre>\n<h3 id="-符号">~ 符号</h3>\n<p><code>echo ~</code> 就知道了, 指向你的<code>Home</code>目录</p>\n<h3 id="命令子句">命令子句</h3>\n<p>形式非常简单，看下面的例子，用<code>$(…)</code>来说明这是条命令子句。值得注意的是只能用在<strong>双引号</strong>内</p>\n<pre><code class="language-bash">$ echo &quot;The File &lt;hello.txt&gt;: $(cat hello.txt)&quot;</code></pre>\n<h3 id="re-use-code">Re-use Code</h3>\n<p>复用代码，是最基本的抽象。为了让我们从简单的命令中更进一步，必须开始思考如何 re-use 代码了。先从Bash的变量开始。</p>\n<h3 id="shell-变量">Shell 变量</h3>\n<p>基本形式</p>\n<pre><code class="language-bash"># error\n$ name = 1 # bash中的`=`左右两边是不允许出现空格的\nbash: name: command not found\n\n# right\n$ name=1\n$ echo $name # 通过`$`去获取变量\n1 # result</code></pre>\n<p>还能用一下上面的命令子句</p>\n<pre><code class="language-bash">$ qiaqia=&quot;$(cat qiaqia.txt)&quot; # good job</code></pre>\n<p>还能在字符串中插入变量 (即: Parameter Expansion)</p>\n<pre><code class="language-bash">$ name=&quot;hali bote&quot; time=23.23\n$ echo &quot;$name&#39;s current record is $times.&quot;\nhali bote&#39;s current record is .\n$ echo &quot;$name&#39;s current record is ${time}s.&quot;\nhali bote&#39;s current record is 23.23s.</code></pre>\n<h3 id="变量扩展-parameter-expansion">变量扩展 Parameter Expansion</h3>\n<p><strong>再次留意</strong>， <code>${variable}</code> 这个形式只能使用在<strong>双引号</strong>之间，接下来要比较详细得讲解一些扩展用法。</p>\n<p>我们来看一个例子</p>\n<pre><code class="language-bash">$ name=Britta time=23.73\n$ echo &quot;$name&#39;s current record is ${time%.*} seconds and ${time#*.} hundredths.&quot;\nBritta&#39;s current record is 23 seconds and 73 hundredths.\n$ echo &quot;PATH currently contains: ${PATH//:/, }&quot;\nPATH currently contains: /Users/lhunath/.bin, /usr/local/bin, /usr/bin, /bin, /usr/libexec\n\n# From Guide Bash</code></pre>\n<p>你可能留意到了<code>${}</code>中的一些特殊用法，<code>%</code>是从后向前匹配最小满足该形式的内容并删去，而<code>#</code>类似前者，不过是从前向后匹配。而下一句命令里的<code>//A/B</code>则是匹配所有满足A形式的内容替换成B。还有一些常见的可以看Bash-Guide的<a href="http://guide.bash.academy/expansions/?=Parameter_Expansion#p2.2.2_5">这个地方</a>，或者是下面的一个简单总结。</p>\n<pre><code class="language-bash"># 例子\nurl=&quot;http://guide.bash.academy/expansions.html&quot;\n$ echo &quot;Result: ${url#*/}&quot; # 从开头开始，匹配满足*/的最小内容，并移除\nResult: /guide.bash.academy/expansions.html\n\n$ ...${url##*/}... # 两个##和一个#的区别在于，匹配的是满足情况的最大内容\nResult: expansions.html\n\n# ${parameter$A} 是从后向前匹配并移除, $$即最大内容\n\n# ${parameter/A/B} 是匹配第一个满足情况A的内容替换成B\n# ${parameter//A/B} 则是匹配所有满足情况的替换\n\n# ${parameter/#A/B} 是从__开头__匹配第一个满足情况A的替换成B\n# ${parameter/%A/B} 则是从__结尾__匹配\n\n# ${#parameter} 计算参数的长度\n# ${parameter:start[:length]} start是截取开始的字符位置，length为截取长度，可省略或者是负数(负数即从后向前数)\n\n# #{parameter[^|^^|,|,,][A]} 根据形式A(不传即匹配任意字符)去把参数转换成^(首个匹配到大写) ^^(所有匹配到大写) ,(首个匹配到小写) ,,(所有匹配到小写)</code></pre>\n<p>再次提醒，这些命令子句都只能使用在<strong>双引号</strong>之间!</p>\n<blockquote>\n<p>MMP bash guide 不更新了… 我得另谋出路</p>\n</blockquote>\n'}})};n.default=function(){return o.createElement(a.a,{Side:o.createElement(c.a,{headings:[{id:"Bash Guide Notes 📒",level:2,parent:null,text:"Bash Guide Notes 📒"},{id:"路径扩展 (Pathname Expansion)",level:3,parent:null,text:"路径扩展 (Pathname Expansion)"},{id:"~ 符号",level:3,parent:null,text:"~ 符号"},{id:"命令子句",level:3,parent:null,text:"命令子句"},{id:"Re-use Code",level:3,parent:null,text:"Re-use Code"},{id:"Shell 变量",level:3,parent:null,text:"Shell 变量"},{id:"变量扩展 Parameter Expansion",level:3,parent:null,text:"变量扩展 Parameter Expansion"}]}),Content:o.createElement(i,null)})}},32:function(e,n,t){"use strict";var o,r=this&&this.__extends||(o=function(e,n){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}o(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});n.__esModule=!0;var a=t(1),s=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return r(n,e),n.prototype.render=function(){var e=this.props,n=e.Side,t=e.Content;return a.createElement("div",null,a.createElement("div",{className:"columns"},a.createElement("div",{className:"side",style:{minWidth:"220px"}},a.createElement("div",{className:"nav section"},n)),a.createElement("div",{className:"content"},t)))},n}(a.PureComponent);n.default=s},33:function(e,n,t){"use strict";var o,r=this&&this.__extends||(o=function(e,n){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}o(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),a=this&&this.__assign||function(){return(a=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var r in n=arguments[t])Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);return e}).apply(this,arguments)};n.__esModule=!0;var s=t(1),c=t(6),i=t(34),p=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return r(n,e),n.prototype.render=function(){var e=this;return this.props.headings.map(function(n,t){return s.createElement(i.default,{key:t,level:n.level},s.createElement(c.Link,a({},e.getLinkProps(n))))})},n.prototype.getLinkProps=function(e){var n=e.text.replace(/\(.*\)/,"");return{dangerouslySetInnerHTML:{__html:n},replace:!1,to:"#"+encodeURIComponent(n)}},n}(s.Component);n.default=p},34:function(e,n,t){"use strict";var o,r=this&&this.__extends||(o=function(e,n){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}o(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)});n.__esModule=!0;var a=t(1),s=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return r(n,e),n.prototype.render=function(){var e=this.props,n=e.level,t=e.children;return a.createElement("div",{className:"nav-label-item level-"+n+" "+(t&&"has-child")},t)},n}(a.PureComponent);n.default=s}}]);