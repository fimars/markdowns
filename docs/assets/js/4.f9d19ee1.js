(window.__LOADABLE_LOADED_CHUNKS__=window.__LOADABLE_LOADED_CHUNKS__||[]).push([[4],{27:function(n,t,a){"use strict";a.r(t);var s=a(0),o=a.n(s),e=a(64),p=a.n(e);t.default=function(){return o.a.createElement(p.a,{renderContent:function(){return o.a.createElement("div",{className:"markdown-body section",dangerouslySetInnerHTML:{__html:'<h1 id="js中的unicode">JS中的Unicode</h1>\n<p>缘起于知识星球的某个用户在自己的名字中使用了<a href="https://codepoints.net/U+202E">U+202E</a>的从右向左显示控制字符，让我对这个事情有了些许的兴趣</p>\n<h3 id="js中使用的unicode版本">js中使用的unicode版本</h3>\n<p>关于Unicode团队和USC团队，从网上随处可见的描述可以得知——目前由于历史原因，JS中的unicode字符确实会带来不大不小的坑。</p>\n<blockquote>\n<p>UTF（Unicode transformation format）Unicode 转换格式，是服务于 Unicode 的，用于将一个 Unicode 码点转换为特定的字节序列。常见的 UTF 有</p>\n<blockquote>\n<p>UTF-8 可变字节序列，用 1 到 4 个字节表示一个码点\nUTF-16 可变字节序列，用 2 或 4 个字节表示一个码点\nUTF-32 固定字节序列，用 4 个字节表示一个码点</p>\n</blockquote>\n<p><a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 对 ASCⅡ编码是兼容的，都是一个字节，超过 U+07FF 的部分则用了复杂的转换方式来映射 Unicode，具体不再详述。</p>\n<p>UTF-16 对于 BMP 的码点，采用 2 个字节进行编码，而 BMP 之外的码点，用 4 个字节组成代理对（surrogate pair）来表示。其中前两个字节范围是 U+D800 到 U+DBFF，后两个字节范围是 U+DC00 到 U+DFFF，通过以下公式完成映射（H：高字节 L：低字节 c：码点）\nH = Math.floor((c-0x10000) / 0x400)+0xD800\nL = (c - 0x10000) % 0x400 + 0xDC00</p>\n<p>比如💩用 UTF-16 表示就是&quot;\\uD83D\\uDCA9&quot;</p>\n<p>UCS（Universal Character Set）通用字符集，是一个 ISO 标准，目前与 Unicode 可以说是等价的。\n相对于 UTF，UCS 也有自己的转换方法（编码）。如</p>\n<blockquote>\n<p>UCS-2 用 2 个字节表示 BMP 的码点\nUCS-4 用 4 个字节表示码点</p>\n</blockquote>\n<p>UCS-2 是一个过时的编码方式，因为它只能编码基本平面（BMP) 的码点，在 BMP 的编码上，与 UTF-16 是一致的，所以可以认为是 UTF-16 的一个子集。\nUCS-4 则与 UTF-32 等价，都是用 4 个字节来编码 Unicode。</p>\n</blockquote>\n<h2 id="常见问题">常见问题</h2>\n<h3 id="字符串处理">字符串处理</h3>\n<p><strong>string.length</strong></p>\n<p>超过BMP的unicode字符的length会得到 2，可以通过正则表达式解决：</p>\n<pre><code class="language-javascript"><span class="token keyword">var</span> regexAstralSymbols <span class="token operator">=</span> <span class="token regex">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g</span><span class="token punctuation">;</span> <span class="token comment">// 匹配UTF-16的代理对</span>\n<span class="token keyword">function</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> string\n      <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>regexAstralSymbols<span class="token punctuation">,</span> <span class="token string">\'_\'</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n<p><strong>string.split</strong></p>\n<p>并且，由上面<code>.length</code>的情况可以猜测得到，<code>.split</code>一样会把这个两位的usc-2码点当作两个字符来处理。如果此时紧随着一个反转操作，不堪入目。（解决办法是通过新的Array.from方法去对字符串进行处理）。</p>\n<p><strong>string.fromCharCode</strong></p>\n<p>这个东西呢，虽然传不了usc-4的值，但是你可以算出高位低位传两个参数进去。不过这也被新方法<code>.fromCharPoint</code>完美解决了。</p>\n<p><strong>正则表达式.匹配</strong></p>\n<p>现在支持u-flag了，就酱</p>\n<pre><code class="language-javascript"><span class="token regex">/foo.bar/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'foo🔟bar\'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\n<span class="token operator">/</span>foo<span class="token punctuation">.</span>bar<span class="token operator">/</span>u<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'foo🔟bar\'</span><span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre>\n<h3 id="号外">号外</h3>\n<p>开头说到的那个用户，就是通过一个控制方向字符达到如下的效果</p>\n<p>字符串内容<code>&quot;某某某亲了(\\u202e下一(\\u202d 回复者&quot;</code>，由于U+202E前面这部分会变成<code>某某某亲了(\\u202d回复者)一下</code>，然后又通过U+202d去让后续回复者的内容从左向右显示，达到了某某某亲了回复者一下的效果。</p>\n<h3 id="参考">参考</h3>\n<ol>\n<li><a href="http://www.alloyteam.com/2016/12/javascript-has-a-unicode-sinkhole/">http://www.alloyteam.com/2016/12/javascript-has-a-unicode-sinkhole/</a></li>\n<li><a href="https://mathiasbynens.be/notes/javascript-unicode">https://mathiasbynens.be/notes/javascript-unicode</a></li>\n</ol>\n'}})}})}},64:function(n,t,a){"use strict";var s=this&&this.__assign||function(){return(s=Object.assign||function(n){for(var t,a=1,s=arguments.length;a<s;a++)for(var o in t=arguments[a])Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o]);return n}).apply(this,arguments)},o=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};t.__esModule=!0;var e=a(22),p=a(12),c=a(7),r=a(0),u=o(a(0));t.default=c.withRouter((function(n){var t=p.siteData.pages.find((function(t){return t.path===n.match.path}))||{path:"",component:""};r.useEffect((function(){t.title&&(console.log(t.title),document.title=t.title)}));var a,o=p.layouts[(a="Layout",t.frontmatter&&t.frontmatter.layout&&(a=t.frontmatter.layout),a)];return u.default.createElement(e.PageDataContext.Provider,{value:t},u.default.createElement(o,s({},n)))}))}}]);