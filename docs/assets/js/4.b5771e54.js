(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{42:function(e,n,o){"use strict";o.r(n);var t=o(1),s=o(47),a=o.n(s),c=o(48),p=o.n(c),l=function(){return t.createElement("div",{className:"markdown-body section",dangerouslySetInnerHTML:{__html:'<h2 id="bash-step-by-step">Bash Step By Step</h2>\n<blockquote>\n<p>翻译：Bash我TM社保 —— 某不愿意透露姓名的Ass We Can大佬(纯虚构)</p>\n</blockquote>\n<h3 id="缘由">缘由</h3>\n<p>这个月我原本是为了填一个MusicApp的坑，准备入Kotlin的。按照之前的经验，学习语言的初期刷题是一个对提高熟练度非常有帮助的方法，但是当我点开CW的语言分类的时候，我惊喜得发现有Bash这个shell。好“骑”心爆棚的我点进了Bash的题库随便点开了一道，然后就蒙住了。我对不起当年的系统课上的linux老师，对不起作业，我决定把Bash捡起来。（Kotlin呢，MusicApp呢？</p>\n<h3 id="起手式">起手式</h3>\n<p><em>PS: 一些有用的资源, Mac only, Sorry for the proletariat.</em></p>\n<ul>\n<li><a href="http://clubmate.fi/upgrade-to-bash-4-in-mac-os-x/">Update Bash In Mac By Brew</a></li>\n<li><a href="https://superuser.com/questions/399594/color-scheme-not-applied-in-iterm2">配合iterm2的高亮</a></li>\n<li><a href="http://guide.bash.academy/">Bash Guide</a> 目前在看的就是这个</li>\n</ul>\n<h2 id="bash-guide-notes-📒">Bash Guide Notes 📒</h2>\n<blockquote>\n<p>Bash Guide: <a href="http://guide.bash.academy/commands/">http://guide.bash.academy/commands/</a></p>\n</blockquote>\n<h3 id="the-chapter-commands-and-arguments">The Chapter: Commands And Arguments</h3>\n<p><strong>预备知识:</strong></p>\n<ol start="0">\n<li><p><del>指令块使用大括号包裹, <code>{ command1; command2 }</code></del></p>\n</li>\n<li><p>Exec指令: 新开一个进程，代替现有的进程。具体可见 <a href="https://askubuntu.com/questions/525767/what-does-an-exec-command-do">这里</a></p>\n</li>\n<li><p><strong>File Descriptor</strong> 见下文</p>\n</li>\n</ol>\n<h4 id="file-descriptor">File Descriptor</h4>\n<p>bash中有一个蛮重要的概念——File Descriptor(后简称FD)，FD是bash程序和外界交互的一个抽象，常见的有FD0(标准输入)、FD1(标准输入)、FD2(标准Error)。可以参考下图：</p>\n<p><img src="http://guide.bash.academy/img/streams.png" alt="File Descriptor"></p>\n<p><del><strong>可能会有用的情报:</strong></del></p>\n<p><del>Bash会为每条<code>指令</code>创建一个<code>subshell</code>，这个会放在后面讲解</del></p>\n<h4 id="基本语法-syntax">基本语法 Syntax</h4>\n<p>注：这里以罗列语法为主，自己可以拿几个常用的指令在bash上试试看, 如: <code>echo</code>, <code>ls</code>, <code>cat</code> 等</p>\n<p><strong>Syntax</strong></p>\n<ol>\n<li><code>[ something ]</code> 指是可选的</li>\n<li><code>[ FORMAT ...]</code> 指重复多个这个格式是合法的</li>\n</ol>\n<p><strong>Command</strong></p>\n<blockquote>\n<p>基本形式:  <code>[环境变量 ...] 指令名 [参数 ...] [FD重定向 ...]</code></p>\n</blockquote>\n<p><strong>List 一串Commands</strong></p>\n<blockquote>\n<p>基本形式 :  <code>command control-operator[ commadn2 control-operator ... ]</code>    </p>\n</blockquote>\n<p>控制操作符包含  <code>|| &amp;&amp; ;</code> <code>||</code>在前者执行失败的时候调用，<code>;</code>在前者执行结束之后调用, <code>&amp;&amp;</code>在前者执行成功之后调用</p>\n<p><strong>Compound Command 混合Command</strong></p>\n<blockquote>\n<p>基本形式:  <code>if list [ ;|&lt;newline&gt; ] then list [ ;|&lt;newline&gt; ] fi</code> 或 <code>{ list ; }</code></p>\n</blockquote>\n<p><strong>Coprocesses 异步Command</strong></p>\n<blockquote>\n<p>基本形式:  <code>coproc [ name ] command [ redirection ... ]</code></p>\n</blockquote>\n<p>注：会在使用这个<code>$name</code>的时候去运行这个指令并拿到即时的结果</p>\n<p><strong>Functions</strong></p>\n<blockquote>\n<p>基本形式: <code>name () compound-command [ redirection ]</code></p>\n</blockquote>\n<p>注：<strong>()内没有参数，一直为空，参数通过$1, $2, $3...获取。</strong></p>\n<p>顺便说一下，一些有用的内置变量:</p>\n<ul>\n<li><code>$$ - PID</code></li>\n<li><code>$! - 后台PID</code></li>\n<li><code>$? - exit code</code></li>\n<li><code>$* - 参数列表 空格分割</code></li>\n<li><code>$@ - 参数列表 回车分割</code></li>\n<li><code>$# 参数个数</code></li>\n</ul>\n<p><strong>Pipeline</strong>  </p>\n<blockquote>\n<p>基本形式: <code>[time [-p]] [ ! ] command [ [|或|&amp;] cmmand2 ... ]</code></p>\n</blockquote>\n<p>注：以下有个简单例子</p>\n<pre><code class="language-bash">$ <span class="token keyword">echo</span> Hello <span class="token operator">|</span> <span class="token function">rev</span>\n<span class="token comment"># output: olleH</span>\n\n$ <span class="token function">rm</span> doesntexistfile <span class="token operator">|</span><span class="token operator">&amp;</span> <span class="token function">rev</span>\n<span class="token comment"># output: yrotcerid ro elif hcus oN :eliftsixetnseod :mr</span>\n\n$ <span class="token function">time</span> <span class="token keyword">echo</span> Hello\n<span class="token comment"># output: Hello &lt;newline>&lt;newline> echo 0m0.004s etc...</span>\n\n<span class="token comment"># ! 关键字暂时没有讨论到，待补充</span></code></pre>\n<p><code>Pipeline</code>具体做的事情就是：把前一条指令的FD1,2，指向了下一跳指令的FD0;</p>\n<p>且有<code>cm1 | cm2</code> ，<code>cm1 |&amp; cm2</code>两种形式。第二种我还是第一次知道呢/doge</p>\n<h4 id="简单命令-simple-commands">简单命令 Simple commands</h4>\n<p>主要内容就两个，一个是基本的命令使用，另外一个就是用于串联命令之间FD的各种重定向符号</p>\n<p><strong>命令 Command</strong></p>\n<p><strong>指令名</strong>：Bash会根据 <code>指令名</code> 去查找 <code>已定义的fn</code> , <code>builtin-fn</code> 或 <code>$PATH</code> 里有的程序去执行，type可以查找指令的所在位置 —— <code>type command</code>。</p>\n<p><strong>参数</strong>：command后面的参数用空格分割，字符串中有空格用<code>&quot;</code>, <code>&#39;</code>包裹或者用<code>\\</code>转义空格。字符串<code>&quot;&quot;</code> 内可包裹变量<code>$variable</code> 或 命令<code>$(command)</code></p>\n<p>请务必留意引号的使用，有个危险的例子可以看看</p>\n<pre><code class="language-bash">$ <span class="token function">read</span> -p <span class="token string">\'Which user would you like to remove from your system ?\'</span> username\n<span class="token comment"># Something Print ...?  lucifa</span>\n\n$ <span class="token function">rm</span> -vr /home/<span class="token variable">$username</span>\n<span class="token comment"># Broken! this command will be:</span>\n<span class="token comment"># -> rm -vr /home/ lucifa</span></code></pre>\n<p><strong>重定向 Redirection</strong></p>\n<blockquote>\n<p> DING, 已获得情报如下：</p>\n</blockquote>\n<ol>\n<li><p><code>command &gt;File</code> 可以把指令的FD1指向File</p>\n</li>\n<li><p><code>command 2&gt;File</code> 可以把指令的FD2指向File</p>\n</li>\n<li><p><code>/dev</code> 下存放的是直接指向系统设备的文件, <code>/dev/null</code> 则是其中一个特殊的存在，这个文件不管写，一直为空。可以把不在意的错误信息指向这个文件。</p>\n</li>\n<li><p>当你很理所当然得使用如下操作时，其实情况非常危险⚠️</p>\n<pre><code class="language-bash">$ <span class="token function">ls</span> -l a b <span class="token operator">></span>myfiles.ls 2<span class="token operator">></span>mayflies.ls\n<span class="token comment"># 理想状态应该是，把正常输入写到myfiles, 然后，把错误信息写到后面</span>\n<span class="token comment"># 实际结果却如下</span>\n<span class="token comment"># -rw-r--r--  1 lhunath  stls: b: No such file or directoryaff  0 30 Apr 14:43 a</span>\n<span class="token comment"># 混乱的结果</span></code></pre>\n<p>因为两个FD同时打开了这个文件流，所以导致混合的结果。正确的操作如下</p>\n<pre><code class="language-bash">$ <span class="token function">ls</span> -l a b <span class="token operator">></span>myfiles.ls 2<span class="token operator">></span><span class="token operator">&amp;</span>1\n<span class="token comment"># 使用 >&amp; 操作符，让FD2指向FD1的文件流</span></code></pre>\n</li>\n<li><p><code>[x]&gt;file, [x]&lt;file</code> 指令的FD1指向文件，指令的FD0从文件输入</p>\n</li>\n<li><p><code>[x]&gt;&amp;y 或 [x]&lt;&amp;y</code> 复制文件指向流，后者的使用场景还没看到, 但在SO某个问题中看到，前后两者的效果几乎一样 <a href="https://unix.stackexchange.com/questions/120532/what-does-exec-31-do">Link</a></p>\n</li>\n<li><p><code>x&gt;&amp;-, x&lt;&amp;-</code> 用<code>-</code>去指向，即是关闭这个FD</p>\n</li>\n<li><p><code>[x]&gt;&amp;y-, [x]&lt;&amp;y-</code>  是 <code>[x]&gt;&amp;y y&gt;&amp;-</code> 的语法糖</p>\n</li>\n<li><p><code>[x]&gt;&gt;file</code> Appending 文件指向</p>\n</li>\n<li><p><code>[x]&amp;&gt;file</code> 同时重定向FD1，FD2到File</p>\n</li>\n<li><p><code>[x]&lt;&gt;file</code> 把FD0, FD1都指向一个文件</p>\n<pre><code class="language-bash">$ <span class="token function">exec</span> 3<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">></span>mylog<span class="token punctuation">;</span> <span class="token keyword">echo</span> moo<span class="token punctuation">;</span> <span class="token function">exec</span> 1<span class="token operator">></span><span class="token operator">&amp;</span>3 3<span class="token operator">></span><span class="token operator">&amp;</span>-\n<span class="token comment"># 这个地方先把当前进程的FD1 copy 到FD3来，然后把FD1指向一个文件</span>\n<span class="token comment"># 接着来一发echo，等于是把输出值写到文件，最后结束的时候exec</span>\n<span class="token comment"># 重新把FD1指回一开始的Display，把FD3抛弃掉</span></code></pre>\n</li>\n<li><p>Here Documents</p>\n<pre><code>command &lt;&lt;[-]分隔符(.)\n    Documents\n分隔符</code></pre><p>直接把分隔符内的内容传输给<code>指令</code>的FD0, 带上<code>-</code>就是忽略内容每行开头的空格。</p>\n</li>\n<li><p>Here Strings, 类似前一个，更精简一些，<code>&lt;&lt;&lt;string</code>即可</p>\n</li>\n</ol>\n'}})};n.default=function(){return t.createElement(a.a,{Side:t.createElement(p.a,{headings:[{id:"Bash Step By Step",level:2,parent:null,text:"Bash Step By Step"},{id:"缘由",level:3,parent:null,text:"缘由"},{id:"起手式",level:3,parent:null,text:"起手式"},{id:"Bash Guide Notes 📒",level:2,parent:null,text:"Bash Guide Notes 📒"},{id:"The Chapter: Commands And Arguments",level:3,text:"The Chapter: Commands And Arguments"},{id:"File Descriptor",level:4,text:"File Descriptor"},{id:"基本语法 Syntax",level:4,text:"基本语法 Syntax"},{id:"简单命令 Simple commands",level:4,text:"简单命令 Simple commands"}]}),Content:t.createElement(l,null)})}},47:function(e,n,o){"use strict";var t,s=this&&this.__extends||(t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var o in n)n.hasOwnProperty(o)&&(e[o]=n[o])})(e,n)},function(e,n){function o(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)});n.__esModule=!0;var a=o(1),c=o(10),p=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return s(n,e),n.prototype.render=function(){var e=this.props,n=e.Side,o=e.Content;return a.createElement("div",null,a.createElement("div",{className:"columns"},a.createElement("div",{className:"side "+(this.props.sideBarDisplay?"sidebar-open":"")},a.createElement("div",{className:"nav"},n)),a.createElement("div",{className:"content main"},o)))},n}(a.PureComponent);n.default=c.connect(function(e){return{sideBarDisplay:e.sideBarDisplay}})(p)},48:function(e,n,o){"use strict";var t,s=this&&this.__extends||(t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var o in n)n.hasOwnProperty(o)&&(e[o]=n[o])})(e,n)},function(e,n){function o(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}),a=this&&this.__assign||function(){return(a=Object.assign||function(e){for(var n,o=1,t=arguments.length;o<t;o++)for(var s in n=arguments[o])Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s]);return e}).apply(this,arguments)};n.__esModule=!0;var c=o(1),p=o(49),l=o(7),r=o(16),i=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return s(n,e),n.prototype.render=function(){var e=this.props.heading;return c.createElement(p.default,{level:e.level},c.createElement(l.Link,a({},this.getLinkProps(e))))},n.prototype.getLinkProps=function(e){var n=e.text.replace(/\(.*\)/,"");return{dangerouslySetInnerHTML:{__html:n},replace:!1,to:"#"+encodeURIComponent(n)}},n}(c.PureComponent);function d(){return c.createElement("div",{className:"sidebar-top"},r.navs.map(function(e){var n=e.text,o=e.link;return c.createElement(l.Link,{key:n,to:o,className:"navstyle"},c.createElement("div",null,n))}))}function m(e){var n=e.headings;return c.createElement("div",{className:"sibar-bottom"},n.map(function(e){return c.createElement(i,{heading:e,key:e.id})}))}var u=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return s(n,e),n.prototype.render=function(){var e=this.props.headings;return c.createElement("div",{className:"sidebar"},c.createElement(d,null),c.createElement(m,{headings:e}))},n}(c.Component);n.default=u},49:function(e,n,o){"use strict";var t,s=this&&this.__extends||(t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var o in n)n.hasOwnProperty(o)&&(e[o]=n[o])})(e,n)},function(e,n){function o(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)});n.__esModule=!0;var a=o(1),c=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return s(n,e),n.prototype.render=function(){var e=this.props,n=e.level,o=e.children;return a.createElement("div",{className:"nav-label-item level-"+n+" "+(o&&"has-child")},o)},n}(a.Component);n.default=c}}]);